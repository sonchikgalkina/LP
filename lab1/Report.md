# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Галкина С. В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки – основная структура данных, применяемая в языке Пролог. Списки являются основой для организации всех сложных вычислений. 

Списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных тем, что они представляют собой рекурсивную структуру данных, состоящую из головы (первого элемента) и хвоста (остальных элементов). Это позволяет удобно работать с данными, особенно при решении задач логического программирования.

Списки в Прологе похожи на связанные списки в традиционных языках программирования, таких как C или Java. Однако, в отличие от связанных списков, списки в Прологе могут быть конечными или бесконечными, что дает большую гибкость и возможности для решения задач.

Списки в Прологе могут быть использованы для хранения любых типов данных, включая числа, строки, символы, другие списки и даже произвольные структуры данных. Списки могут быть созданы как вручную, так и с помощью встроенных предикатов.

Один из наиболее распространенных способов работы со списками в Прологе - это рекурсивные функции. Рекурсивная функция - это функция, которая вызывает саму себя с измененными параметрами. Это позволяет обрабатывать списки рекурсивно, перебирая каждый элемент списка и выполняя определенные действия.

Списки также могут быть использованы для решения задач логического программирования, таких как поиск путей в графах или поиск решений логических головоломок. Например, задача о восьми ферзях может быть решена с использованием списков и рекурсивных функций.

В целом, списки в Прологе представляют собой мощный инструмент для работы с данными и решения задач логического программирования. Их рекурсивная структура данных позволяет эффективно обрабатывать списки любой длины и сложности, что делает их незаменимым инструментом для разработки программ на Прологе.

## Задание 1.1: Предикат обработки списка

В прологе список представляет собой упорядоченную последовательность элементов, заключенных в квадратные скобки и разделенных запятыми. Элементы списка могут быть любого типа данных, включая другие списки. Для работы с элементами списка в прологе используются различные предикаты и функции обработки списков.


## Задание 1.1: Предикат обработки списка

`delete_first(X, N, Y)` - Предикат удаляет первые N элементов из списка X. Результатом удаления первых N элементов из X будет являться список Y.

`delete_first1(X, N, Y)` - Предикат делает то же самое, что и предиакт `delete_first`, то есть удаляет первые N элементов из списка X и выводит резельтат - список Y, но реализован он с помощью стандартных предикатов для работы со списками.

Примеры использования:

```prolog
?- delete_first([5, 3, 6, 7, 8, 1], 2, [6, 7, 8, 1]).
true
?- delete_first([a, f, g, d, c, t], 4, X).
X = [c, t]
?- delete_first1([a, b, c, d, e, f, g], 6, X).
X = [g]
```

Реализация:

Без использования стандартных предикатов

```prolog
delete_first(X, 0, X).
delete_first([X|Y], N, Z) :-
	delete_first(Y, Q, Z),
	N is Q + 1.
```

 С использованием стандартных предикатов

```prolog
 delete_first1(X, N, Y) :-
	my_append(A, Y, X),
	my_length(A, N).
```

При реализации предиката `delete_first(X, N, Y)` мы сначала определяем предикат при удалении 0 элемнетов. В этом случае список Y не изменится, то есть будет списком X. Далее рекурсивно определяем предикат для N элементов. Определяем, что удаление из списка `[X|Y]` N элементов значит то же, что и удаление из списка Y Q элементов, причем N должно быть равно Q + 1.

При реализации предиката `delete_first1(X, N, Y)` используем стандартные предикаты для работы со списками `my_append` и `my_lenght`, которые были заранее реализованы. Удаляем из списка X N элементов и получаем в результате список Y, если мы можем найти такое разбиение списка X на 2 части, где первой частью будет список A, а второй частью будет список Y, причем длина списка A должна быть равна N.

## Задание 1.2: Предикат обработки числового списка

`lexic_compare([], [])`, `lexic_compare1([X|Tail], [Y|Tail])` - лексиграфическое сравнение двух списков. Предикат принимает два списка. Выводит `true`, если они равны, `false`, если не равны.

Примеры использования:

```prolog
?- lexic_compare([2, 4, 6, 3], [2, 4, 6, 3]).
true
?- lexic_compare([a, e, f, c, h], [a, r, f, c, g]).
false
?- lexic_compare1([a, b, c, h], [a, b, c, l]).
false
```

Реализация:

Без использования стандартных предикатов

```prolog
lexic_compare([X|Tail], [Y|Tail]) :- X =:= Y, lexic_compare(Tail, Tail).
lexic_compare([X], [Y]) :- X =:= Y.
```

С использованием стандартных предикатов

```prolog
lexic_compare1([], []).
lexic_compare1([X|Tail], Y) :- my_remove(Y, X, Y1), lexic_compare1(Tail, Y1).
```

При реализации предиката `lexic_compare[X|Tail], [Y|Tail])` определяем предикат с двумя списками. Используем рекурсию для сравнения головных элементов списков `[X|Tail]` и `[Y|Tail]`. Если головные элементы равны `(X =:= Y)`, то рекурсивно вызываем предикат `lexic_compare` для хвостов списков `(Tail, Tail)`. Если головные элементы не равны, то результатом будет `false`. Если списки состоят только из одного элемента, то сравниваем эти элементы и возвращаем `true`, если они равны, и `false` в противном случае.

При реализации предиката `lexic_compare1([], [])` сначала рассматриваем базовый случай, когда оба списка пусты. В этом случае результатом будет `true`. Далее используем рекурсию для сравнения головных элементов списков `[X|Tail]` и Y. Вызывает предикат `my_remove` для удаления из списка Y первого вхождения элемента X. Если элемент X был найден и удален, то рекурсивно вызываем предикат lexic_compare1 для хвостов списков `(Tail, Y1)`. Если элемент X не был найден, то результатом будет `false`. Если первый список состоит только из одного элемента, то сравниваем этот элемент с головным элементом второго списка и возвращаем `true`, если они равны, и `false` в противном случае.

## Задание 2: Реляционное представление данных

Преимущества реляционного представления:

1. Гибкость: Реляционное представление позволяет описывать отношения между объектами, а не только их свойства. Это позволяет описывать сложные структуры данных отношения между ними.
2. Декларативность: Реляционное представление позволяет описывать задачу в терминах отношений между объектами, а не в терминах последовательности действий. Это делает программу более легкочитаемой и понятной.
3. Мощность: Реляционное представление позволяет использовать различные стратегии поиска решений, такие как поиск в ширину, поиск в глубину, обратный поиск и т.д. Это позволяет решать сложные задачи, которые были бы трудными или невозможными для других языков программирования.

Недостатки реляционного представления:

1. Производительность: Реляционное представление может быть неэффективным для больших объемов данных или сложных задач. Это связано с тем, что поиск решения может занимать много времени и ресурсов.
2. Сложность: Реляционное представление может быть сложным для понимания и написания. Это связано с тем, что оно требует мышления в терминах отношений между объектами, а не в терминах последовательности действий.
3. Ограничения: Реляционное представление может иметь ограничения в том, какие задачи можно решить. Некоторые задачи могут быть трудными или невозможными для реляционного представления, например, задачи, связанные с численными вычислениями или работой с графическими интерфейсами.

Описание предикатов

Предикат `group_point_average_print()` получает таблицу групп и средний балл по каждой из групп. Для этого он проходит по списку групп, вызывает предикат `students_point_average_in_group()` для каждой группы, который возвращает список средних баллов студентов в группе. Затем предикат `arithm_mean()` вычисляет среднее значение списка и выводит результат на экран.

Предикат `print_repass()` получает список студентов, не сдавших экзамен (grade=2) по каждому предмету. Для этого он проходит по списку предметов, вызывает предикат `repass()` для каждого предмета, который возвращает список студентов, не сдавших экзамен. Затем он выводит результат на экран.

Предикат `print_num_repass()` получает количество не сдавших студентов в каждой из групп. Для этого он проходит по списку групп, вызывает предикат `num_repass_in_group()` для каждой группы, который возвращает количество студентов, не сдавших экзамен. Затем он выводит результат на экран.

Каждый из этих предикатов использует другие предикаты и функции, такие как `sum()`, `arithm_mean()`, `mark()`, `student_point_average()` и другие, которые помогают вычислить необходимые значения и данные для вывода на экран.

Реализация

Для варианта №1 используем `four.pl`

№1 Получить таблицу групп и средний балл по каждой из групп

```prolog
sum([], 0).
sum([X|Y], S) :-
	sum(Y, Q),
	S is Q + X.

arithm_mean(X, T) :-
	length(X, L),
	sum(X, P),
	T is P / L.

mark(Student, N) :-
	subject(_, X),
	member(grade(Student, N), X).

student_point_average(Student, Res) :-
	findall(N, mark(Student, N), List),
	arithm_mean(List, Res).

students_point_average_in_group(Group, Res) :-
	group(Group, StudList),
	member(Stud, StudList),
	student_point_average(Stud, Res).

group_point_average_print() :-
	group(Group, _),
	findall(Res, students_point_average_in_group(Group, Res), ListValue),
	arithm_mean(ListValue, Ans),
	write('Группа: '), write(Group), write(' средний балл: '), write(Ans), write('\n'), fail.
```

№2 Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)

```prolog
repass(Subj, Name) :-
	subject(Subj, Students),
	member(grade(Name, 2), Students).

print_repass() :-
	subject(Subj, _),
	findall(Name, repass(Subj, Name), List),
	write('Предмет: '), write(Subj), write(' не сдали: '), write(List), write('\n'), fail.
```

№3 Найти количество не сдавших студентов в каждой из групп

```prolog
group_repass(Group, Name) :-
	subject(_, X),
	group(Group, Y),
	member(Name, Y),
	member(grade(Name, 2), X).

num_repass_in_group(Group, Num) :-
	findall(Name, group_repass(Group, Name), List),
	length(List, Num).
	
print_num_repass() :-
	group(Group, _),
	num_repass_in_group(Group, Num),
	write('Группа: '), write(Group), write(' не сдавших: '), write(Num), write('\n'), fail.
```

Пример работы:

```prolog
?- group_point_average_print.
Группа: 102 средний балл: 3.9444444444444446
Группа: 101 средний балл: 3.9666666666666672
Группа: 104 средний балл: 3.861111111111111
Группа: 103 средний балл: 4.145833333333334
false.

?- print_repass.
Предмет: Логическое программирование не сдали: [Петровский,Сидоров,Джаво]
Предмет: Математический анализ не сдали: [Петров]
Предмет: Функциональное программирование не сдали: []
Предмет: Информатика не сдали: [Сиплюсплюсов,Криптовалютников]
Предмет: Английский язык не сдали: [Решетников,Азурин]
Предмет: Психология не сдали: [Безумников,Круглосчиталкин]
false.

?- print_num_repass.
Группа: 102 не сдавших: 3
Группа: 101 не сдавших: 3
Группа: 104 не сдавших: 2
Группа: 103 не сдавших: 2
false.
```

## Выводы

В ходе выполнения лабораторной работы на прологе были изучены основные принципы работы с реляционными данными и предикатами обработки списков и числовых значений. Были рассмотрены различные функции и предикаты, которые помогают вычислять необходимые значения и данные для вывода на экран.

Лабораторная работа позволила получить опыт работы с реляционной моделью данных и показала, что она может быть очень удобной для обработки больших объемов информации. Были изучены предикаты обработки списка и числового списка, которые могут быть полезны в различных проектах.

Работа на прологе заставила задуматься о том, как можно использовать реляционную модель данных в реальных проектах и какие преимущества это может дать. Также было интересно изучить, как работает пролог и как его можно использовать для решения различных задач.

Написание кода на прологе оказалось не слишком сложным, но требовало аккуратности и внимания к деталям. В целом, лабораторная работа на прологе позволила получить ценный опыт работы с реляционными данными и предикатами обработки списков и числовых значений, что может быть полезным в будущих проектах.
